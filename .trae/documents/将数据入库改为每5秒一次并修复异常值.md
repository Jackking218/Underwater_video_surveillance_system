## 原因分析
- 当前在 DataView 的 500ms 模拟定时器每次都会调用记录函数，导致 1s 内写入两次及更高频率，观察上会出现密集数据。
- 表中出现只显示日期的 log_time 与异常的 speed 值，极可能是历史 MySQL 表结构与代码不一致：log_time 被建成 DATE，speed/accel/dist 不是 DOUBLE（或旧表残留），IF NOT EXISTS 不会纠正旧结构。
- 也可能是 UI 查看工具格式化造成；需用 DESCRIBE ship_logs 验证字段类型并抽样查询确认。

## 修改方案
1. 记录间隔改为 5s（保留 500ms 的动画/图表刷新）：
   - 在 DataView 增加独立保存定时器 m_saveTimer，间隔 5000ms，仅在其超时回调中调用 recordDataToDb。
   - 从 500ms 模拟定时器中移除 recordDataToDb 调用。
   - 可选：在 config.ini 增加 Database/SaveIntervalSeconds=5，使间隔可配置并在启动时读取。

2. 表结构统一为 MySQL 目标结构：
   - log_time 改为 DATETIME，speed/accel/dist 改为 DOUBLE。
   - 新建时使用：
     CREATE TABLE IF NOT EXISTS ship_logs(
       id INT AUTO_INCREMENT PRIMARY KEY,
       log_time DATETIME,
       speed DOUBLE,
       accel DOUBLE,
       dist DOUBLE
     );
   - 如果 DESCRIBE 发现现有结构不匹配，执行 ALTER：
     - ALTER TABLE ship_logs MODIFY log_time DATETIME NULL;
     - ALTER TABLE ship_logs MODIFY speed DOUBLE;
     - ALTER TABLE ship_logs MODIFY accel DOUBLE;
     - ALTER TABLE ship_logs MODIFY dist DOUBLE;

3. 防护与日志：
   - 在插入前对 speed/accel/dist 做范围与 NaN 检查，异常则跳过或钳制并打印 qDebug。
   - 插入成功后打印一次简要日志，含时间戳与数值，便于核对。

## 代码级改动点
- dataview.cpp
  - 构造函数中创建 m_saveTimer（5000ms）并连接到 recordDataToDb。
  - 移除 500ms 定时器中的 recordDataToDb 调用。
  - 读取 config.ini 的 Database/SaveIntervalSeconds（若存在则覆盖 5000ms）。
- Database/dbmanager.cpp
  - 建表语句改为 DATETIME 与 DOUBLE 类型。
  - 在 insertLog 内增加数值校验与日志输出。

## 验证
- 运行 1 分钟应产生约 12 条记录（5s 间隔）。
- 在历史页查看间隔是否稳定，并抽查数据库：
  SELECT log_time, speed, accel, dist FROM ship_logs ORDER BY id DESC LIMIT 20;
- 用 DESCRIBE ship_logs 确认字段类型正确。

请确认是否按上述方案改动；确认后我将提交具体代码修改并完成验证。